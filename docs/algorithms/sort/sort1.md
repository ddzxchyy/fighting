

# 排序算法

[极客时间-数据结构与算法之美](https://time.geekbang.org/column/article/41802)

## 如何分析一个排序算法

### 1. 排序算法的执行效率

对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：

**(1) 最好情况、最坏情况、平均情况时间复杂度** 

在分析算法的时间复杂度时, 要分别给出最好情况、最坏情况平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。

**(2) 时间复杂度的系数、常数 、低阶**

 我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据。所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。 

**(3) 比较次数和交换（或移动）次数** 

基于比较的排序算法, 会涉及二种操作, 一种是元素比较大小, 另一种是元素交换或移动。

### 2.  排序算法的内存消耗
算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

### 3. 排序算法的稳定性

稳定性指的待排序的序列中如果存在值相等的元素，排序过后，原有的顺序不变。



## 冒泡排序

冒泡排序操作相邻的二个元素进行比较，如果不满足有序的条件就交换他们的位置，重复 n  次。

冒泡排序的特点：

1. 原地排序
2. 可以是稳定的排序
3. 时间复杂度为  O(n<sup>2</sup>)

冒泡排序的时间复杂度：

1. 最好情况时间复杂度为 O(n) ，待排序的序列为有序， 有序度为 C<sup>n</sup><sub>2</sub>
2. 最坏情况时间复杂度为 O(n<sup>2</sup>)， 待排序的序列为倒序， 有序度为 0
3. 平均时间复杂度为 O(n<sup>2</sup>)

   

冒泡排序的平均时间复杂度的非正式计算：通过**有序度**和**逆序度**来分析计算。

冒泡排序的时间主要在于交换元素，它需要交换的次数为序列的逆序对的个数。对于一个有序的数组[1, 2, 3, 4, 5, 6]，它的有序度为 C<sup>6</sup><sub>2</sub> = 6 * (6 - 1) / 2 = 15 。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n * (n - 1) / 2 次交换。最好情况下，初始状态的有序度是 n * (n - 1) / 2，就不需要进行交换。我们可以取个中间值 n * (n - 1) / 4，来表示初始有序度既不是很高也不是很低的平均情况。

!> 逆序对： 如果 i < j，有 a[i] > a[j]，则 a[i] 与 a[j] 为逆序对。

```java
 public static void bubbleSort(int[] arr) {
        int arrLength = arr.length;
        /*
         * 有标志位 10K 条数据耗时在 130 ms 左右, 无标志位平均耗时 130 ms。
         */
        boolean isNoSwapped = true;
        for (int i = 0; i < arrLength; i++) {
            int sortedArrLength = arrLength - i - 1;
            isNoSwapped = true;
            for (int j = 0; j < sortedArrLength; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    isNoSwapped = false;
                }
            }
            if (isNoSwapped) {
                return;
            }
        }
    }
```



## QA
**1. 为什么要说出三种不同的时间复杂度**

答  因为数据的有序度不同, 会影响算法的执行时间. 所以我们要知道排序算法在不同数据下的性能表现。

**2. 为什么需要说明算法是否稳定**

答：在实际软件开发中待排序的对象一般不是整数，而是一组对象，我们需要按照对象的某个 key 来排序。

比如订单系统中有这么个需求：要按订单的价格降序，对于价格相同的订单按时间升序。

这个需求就可以用稳定的排序算法来实现。先按时间排序，再按价格排序即可。	