# 快速排序

快速排序和归并排序相同，都使用了分治思想。它将数组划分为三个区间：**小于主元的部分、主元、大于主元的部分，然后通过递归调用快速排序，直到区间的长度为 1** 。因为子数组都是原址排序的，所以不需要合并：数组已经有序。



## 实现

算法的关键部分是 PARTITION 过程，它实现了对子数组的原址重排。

partition 方法需要实现以下功能：

1. 返回主元索引，即下一次快排数组的最后索引
2. 遍历数组，将数组分为小于主元的部分和大于主元的部分
3. 将主元交换合适的位置



```java
public class QuickSort {

    public static void sort(int[] a) {
        quickSort(a, 0, a.length - 1);
    }

    private static void quickSort(int[] a, int p, int r) {
        if (p < r) {
            int q = partition(a, p, r);
            quickSort(a, p, q - 1);
            quickSort(a, q + 1, r);
        }
    }

    /**
     * 获取分区点
     * partition 方法需要实现以下功能：
     * 1. 返回主元索引，即下一次快排数组的最后索引
     * 2. 遍历数组，将数组分为小于主元的部分a[p, i]和大于主元的部分 a[i + 1,j]
     * 3. 将主元交换合适的位置
     **/
    private static int partition(int[] a, int p, int r) {
        int pivot = a[r];
        int i = p - 1;
        for (int j = p; j <= r - 1; j++) {
            if (a[j] <= pivot) {
                i++;
                ArrayUtil.swap(a, i, j);
            }
        }
        ArrayUtil.swap(a, i + 1, r);
        return i + 1;
    }

    public static void main(String[] args) {
        int[] a = ArrayUtil.getRandIntArray(8);
        sort(a);
        System.out.println(Arrays.toString(a));
    }
}

```



## 特点

**一、是否是原址排序？**

排序过程不需要额外的存储空间，所以空间复杂度为 O(1),  是原址排序。



**二、是否是稳定排序？**

算法每次将最小值和循环不变式的下一个值做交换，破坏了稳定性。所以选择排序不是稳定的排序算法。

一、

## 性能

快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。如果划分是平衡的，那么快速排序的性能与归并排序相同。如果划分不平衡，那么快速排序的性能接近于插入排序。



### 最坏情况划分

当划分产生的二个子问题分别包含了 n - 1个元素和 0 个元素时， 快速排序的最坏情况发送了。假设每次划分都是这种情况。划分操作的时间复杂度是 Θ(n) 。由于对一个大小为 0 的数组进行递归调用会直接返回，因此 T(0) = Θ(1), 于是算法运行时间的递归式可以表示为：

`T(n) = T(n-1) + T(0) + Θ(n) = T(n - 1) + Θ(n)`

每一层递归的代价可以被累加起来，从而得到一个算术级数  Σ n = n * （n -1) / 2 = Θ(n^2)



### 最好情况划分

在可能的最平衡划分中，两个子问题的规模都不大于 n/2 ，这种情况下算法运行时间的递归式为：

`T(n) = 2T(n/2) + Θ(n)`

根据主定理的情况 2 ，得到 T(n) = Θ(nlgn)



### 平衡的划分

快速排序的平均运行时间更接近于最好情况，而非最坏情况。假设划分算法总是产生 9:1 的划分，则快速排序时间复杂度的递归式为：

`T(n) = T(n/10) + T(9n/10) + cn`

常数比例的划分，总会产生深度为 lgn 的递归树，其中每一层时间代价都是 O(n)。 因此只要是常数比例的划分，算法的运行时间总是 O(nlgn) 。



## 思考

O(n) 时间复杂度内求无序数组中的第 K 大元素。 

