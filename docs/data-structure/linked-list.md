# 链表

一种线性表数据结构，它通过指针将零散的内存块串联在一起，每个内存块称为一个节点。常用的列表有三种：单链表、双向链表、循环链表。



## 开篇问题

 如何基于链表实现 LRU 缓存淘汰算法？ 



## 特点

相较于数组，链表具有查询慢，插入快的特点。

链表查询慢是因为它没有申请连续的内存空间，不能通过寻址公式直接得到内存地址。它需要从头结点开始，通过后续指针一个个往下找，平均时间复杂度为 O(n)。

链表插入快是因为不需要进行数据的迁移操作。假设要插入的节点为  B，它的上一个节点为 A。单链表插入操作的话只需要将节点 B的后续指针设置为 A 的后续指针，并将 A 的后续指针指向 B。链表的插入操作时间复杂度为 O(1)。



## 双向链表

 在实际的软件开发中，从链表中删除一个数据无外乎这两种情况： 

* A. 删除结点中“值等于某个给定值”的结点。
* B. 删除给定指针指向的结点。

单链表的删除操作时间复杂度为 O(1)，这种说法其实是不准确的，单纯的删除操作的确是 O(1)，但是为了要找到要删除的元素所需要的时间复杂度为 O(n)。根据加法法则,针对情况 A 的删除操作总时间复杂度为 O(n)。

针对情况 B ，由于单链表只有后续指针，并不能直接找到要删除的节点的前面一个节点的地址，无法修改前一个节点的后续指针，所以还是需要从头结点开始遍历。

双向链表在单链表的基础上，在每个节点上添加了一个前驱指针，从而解决了单链表需要从头遍历的缺点。

在链表的某个指定结点前面插入一个结点，双向链表插入的时间复杂度为 O(1)，单链表插入的时间复杂度为 O(n)。

虽然双向链表需要更多的内存空间，但是它更加高效。所以实际项目中应用的更加广发。

!> 双向链表的设计体现了**时间换空间**的思想。